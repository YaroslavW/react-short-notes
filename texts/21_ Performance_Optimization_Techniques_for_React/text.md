# 21 техника оптимизации производительности для React.

![img-21-react](img/21-react-per.jpg)

Статья посвящена оптимизации производительности приложения React. React предлагает множество оптимизаций для проектирования высокопроизводительных приложений, чего можно достичь, следуя некоторым из этих передовых методов.

Родительский и дочерний компоненты часто перерисовываются в следующем сценарии:

1. **Когда «setState» вызывается** в том же компоненте или родительском компоненте.
2. **Изменение значения «props»**, полученного от родителя.
3. Вызов `forceUpdate` в компоненте.

Ниже приведены 21 методика, которую мы можем использовать для повышения производительности наших приложений React.

## 1. Использование чистых компонентов

Компонент React можно считать чистым, если он выдает одинаковые выходные данные для того же состояния и реквизита. Для таких компонентов класса React предоставляет базовый класс `PureComponent`. Компоненты класса, расширяющие класс `React.PureComponent`, рассматриваются как чистые компоненты.

Это то же самое, что и обычный компонент, за исключением того факта, что `PureComponents` заботится о `shouldComponentUpdate` - он выполняет *поверхностное сравнение* состояния и данных реквизита - props. Если предыдущее состояние и данные реквизита совпадают со следующими реквизитами или состоянием, компонент не визуализируется повторно.

### Что такое неглубокий рендеринг.

При сравнении предыдущих реквизитов - props и состояния - state со следующим, поверхностное сравнение проверит, что примитивы имеют одинаковое значение (например, `1` равно `1` или что `true` равно `true`) и что *ссылки (references)* одинаковы между более сложными значениями JavaScript, такими как объекты и массивы.

Сравнение примитивных и объектных ссылок является более дешевой операцией, чем обновление представления компонента. Поэтому поиск изменений в состоянии и значениях реквизита будет выполняться быстрее, а не делать ненужные обновления.

```javascript

import React from 'react';

export default class ApplicationComponent extends React.Component {

    constructor() {
        super();
        this.state = {
            name: "Mayank"
        }
    }

    updateState = () => {
        setInterval(() => {
            this.setState({
                name: "Mayank"
            })
        }, 1000)
    }

    componentDidMount() {
        this.updateState();
    }

    render() {

        console.log("Render Called Again")
        return (
            <div>
                <RegularChildComponent name={this.state.name} />
                <PureChildComponent name={this.state.name} />
            </div>
        )
    }
}

class RegularChildComponent extends React.Component {
    render() {
        console.log("Regular Component Rendered..");
        return <div>{this.props.name}</div>;
    }
}

class PureChildComponent extends React.PureComponent {
    
    // Pure Components are the components that do not re-render if the State data or props data is still the same   
    
    render() {
        console.log("Pure Component Rendered..")
        return <div>{this.props.name}</div>;
    }
}
```

В приведенном выше примере состояние распространяется на дочерние компоненты `RegularChildComponent` и `PureChildComponent`. `PureChildComponent` является чистым компонентом. После интервала в 1 секунду вызывается `setState`, который повторно запускает рендеринг представления для компонента, поскольку начальные значения и новые значения параметров одинаковы, компонент (`PureChildComponent`) не будет повторно отображаться.

Неглубокое сравнение состояния показывает, что никаких изменений в данных нет ни для реквизита, ни для состояния, поэтому компонент не нужно визуализировать. Следовательно, делая компонент более эффективным.

## 2. Используйте React.memo для запоминания компонентов.

`React.memo` является компонентом высшего порядка. Он похож на `PureComponent`, но `PureComponent` относится к реализации класса для `Component`, тогда как **«memo»** используется для создания функциональных компонентов.

Подобно чистым компонентам, если входные свойства одинаковы, рендеринг компонента будет пропущен, что сделает компонент более быстрым и эффективным. Он запоминает результаты последнего выполнения для определенных входных параметров и повышает производительность приложения. Даже в этих компонентах сравнение невелико. Вы также можете передать пользовательскую логику сравнения для этого компонента.

Пользовательская логика может позволить пользователю искать *глубокое сравнение* объекта, если функция сравнения возвращает `false`, компонент будет перерисован, в противном случае перерисовка компонента отсутствует.

```javascript

function CustomisedComponen(props) {
    return (
        <div>
            <b>User name: {props.name}</b>
            <b>User age: {props.age}</b>
            <b>User designation: {props.designation}</b>
        </div>
    )
}

// The component below is the optimised version for the Default Componenent

// The Component will not re-render if same props value for "name" property 

var memoComponent = React.memo(CustomisedComponent);

```
Вышеупомянутый компонент будет выполнять *поверхностное сравнение* для предыдущего и следующего значения реквизита, в случаях, когда у нас есть ссылки на объекты, переданные в качестве реквизитов для компонента «memo», для сравнения должен быть установлен некоторый пользовательский логин, в таких случаях мы можем передать функцию сравнения в качестве второго параметра в функцию **«React.memo»**.

Предположим, что значение реквизита - props («user») является ссылкой на объект, содержащей «name», «age» и обозначение - «designation» для конкретного пользователя. В этом случае необходимо провести *глубокое сравнение*, мы можем создать пользовательскую функцию, которая ищет значение имени, возраста и назначения для предыдущего и следующего значения реквизита и возвращает `false`, если они не совпадают. Таким образом, наш компонент не будет повторно визуализироваться, даже если у нас есть справочные данные в качестве входных данных для компонента «memo».

```javascript

// The following function takes "user" Object as input parameter in props

function CustomisedComponen(props) {
    return (
        <div>
            <b>User name: {props.user.name}</b>
            <b>User age: {props.user.age}</b>
            <b>User designation: {props.user.designation}</b>
        </div>
    )
}

function userComparator(previosProps, nextProps) {
    if(previosProps.user.name == nextProps.user.name ||
       previosProps.user.age == nextProps.user.age ||
       previosProps.user.designation == nextProps.user.designation) {
        return false
    } else {
        return true;
    }
}

var memoComponent = React.memo(CustomisedComponent, userComparator);

```

В приведенном выше коде, мы представили пользовательскую логику для сравнения.

## 3. Использование события жизненного цикла `shouldComponentUpdate`.

Это одно из событий жизненного цикла, которое запускается перед повторной визуализацией компонента. Мы можем эффективно использовать это событие, чтобы решить, когда компонент должен быть перерисован. Эта функция возвращает логическое значение в случае, если компонент поддерживает изменения или вызывается setState. В обоих случаях компонент имеет тенденцию к повторной визуализации. Мы можем поместить собственную логику в это событие жизненного цикла, чтобы решить, будет ли вызвана функция рендеринга компонента.

Эта функция принимает в качестве входных данных `nextState` и `nextProps` и может сравнивать их с текущими реквизитами и состоянием, чтобы определить необходимость повторной визуализации.

### Давайте разберемся с помощью сценария:

Я хочу отобразить информацию о сотруднике на веб-странице, каждый сотрудник содержит несколько свойств, таких как имя, возраст, назначение, зарплата, текущий менеджер, предыдущий менеджер, бонус и т. Д. Из всех этих данных я хочу отобразить только имя и возраст для выбранного сотрудника на моей веб-странице. В какой-то момент времени назначение сотрудника обновляется, поскольку назначение сотрудника не является частью представления, в идеале представление не нужно обновлять. Мы можем добавить пользовательскую логику в компонент, чтобы увидеть, требуется ли компоненту обновлять представление или нет.

Посмотрим указанный сценарий с помощью программы:

```javascript

import React from "react";

export default class ShouldComponentUpdateUsage extends React.Component {

  constructor(props) {
    super(props);
    this.state = {
      name: "Mayank";
      age: 30,
      designation: "Architect";
    }
  }
  
  componentDidMount() {
    setTimeout(() => {
      this.setState({
        designation: "Senior Architect"
      });
    }
  }
               
  shouldComponentUpdate(nextProps, nextState) {
      if(nextState.age != this.state.age || netState.name = this.state.name) {
        return true;
      }
      return false;
  }
  
  render() {
    return (
      <div>
        <b>User Name:</b> {this.state.name}
        <b>User Age:</b> {this.state.age}
      </div>
    )
  }
}

```

Здесь, даже когда обозначение в компоненте меняется, это не повлияет на представление приложения. Поскольку вызывается `setState`, компонент имеет тенденцию к повторной визуализации, поскольку изменение «обозначения» - `designation` не изменяет / не влияет на представление компонента, поэтому повторная визуализация компонента при изменении обозначения будет непроизводительной. Чтобы избежать этих издержек, мы можем иметь собственную логику, чтобы проверить, обновляется ли имя или возраст, потому что на представление влияют только имя или возраст.

`shouldComponentUpdate` принимает входной параметр в качестве новых значений состояния и реквизита. Мы можем сравнить текущее и новое значение имени и возраста, если любое из них изменится, мы можем запустить повторную визуализацию. Передача «`true`» из `shouldComponentUpdate` уведомляет, что компонент может быть повторно обработан и наоборот. Так что, если `shouldComponentUpdate` используется правильно, мы можем оптимизировать производительность компонента приложения.

Сравнивая начальные состояния и свойства, мы можем принять решение о том, нужно ли повторно визуализировать компонент или нет. И это повысит производительность приложения, сделав меньше циклов повторного рендеринга.

## 4. Использование отложенной загрузки компонентов

Building - это процесс импорта и объединения нескольких файлов в один файл, так что приложению не нужно импортировать много внешних файлов. Все основные компоненты и внешние зависимости объединяются в один файл и отправляются по сети для построения и запуска веб-приложения. Это экономит много сетевых вызовов, но также приводит к проблеме, когда этот единственный файл становится большим файлом и потребляет большую пропускную способность сети. Приложение продолжает ожидать загрузки и выполнения этого большого файла, поэтому задержка передачи этого файла по сети приводит к увеличению времени рендеринга приложения.

Чтобы решить эту проблему, можно включить концепцию «Разделение кода» - **Code Splitting**. Концепция разделения кода поддерживается такими пакетами, как Webpack, которые могут создавать несколько пакетов для приложения, которые можно динамически загружать во время выполнения.

Загрузка во время выполнения уменьшает размер исходного создаваемого пакета, мы можем планировать разбиение пакетов таким образом, чтобы компоненты, которые изначально не загружались в приложение, могли быть отложены для загрузки позже, когда они потребуются, это уменьшит размер основного пакета и уменьшит время загрузки приложения. Мы используем «Suspense» и «Lazy» для того же.

```javascript

import React, { lazy, Suspense } from "react";

export default class CallingLazyComponents extends React.Component {
  render() {
    
    var ComponentToLazyLoad = null;
    
    if(this.props.name == "Mayank") { 
      ComponentToLazyLoad = lazy(() => import("./mayankComponent"));
    } else if(this.props.name == "Anshul") {
      ComponentToLazyLoad = lazy(() => import("./anshulComponent"));
    }
    return (
        <div>
            <h1>This is the Base User: {this.state.name}</h1>
            <Suspense fallback={<div>Loading...</div>}>
                <ComponentToLazyLoad />
            </Suspense>
        </div>
    )
  }
}

```

В приведенном выше коде у нас есть условный оператор, который ищет значение реквизита и в соответствии с указанным условием загружает любой из двух компонентов основного компонента. Первоначальная загрузка обоих этих компонентов в основной комплект увеличит общий размер комплекта. В любой момент времени мы требуем, чтобы один из двух компонентов был представлен. Поэтому загрузка всех компонентов, которые могут быть добавлены или не добавлены в представление, приведет к снижению производительности. Мы можем лениво загружать компоненты, когда это необходимо, и эти компоненты являются частью отдельного чанка, загружаемого во время выполнения и повышающего общую производительность приложения.

Мы поймем это с помощью другого примера.



