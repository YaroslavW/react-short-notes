# 21 техника оптимизации производительности для React.

![img-21-react](img/21-react-per.jpg)

Статья посвящена оптимизации производительности приложения React. React предлагает множество оптимизаций для проектирования высокопроизводительных приложений, чего можно достичь, следуя некоторым из этих передовых методов.

Родительский и дочерний компоненты часто перерисовываются в следующем сценарии:

1. **Когда «setState» вызывается** в том же компоненте или родительском компоненте.
2. **Изменение значения «props»**, полученного от родителя.
3. Вызов `forceUpdate` в компоненте.

Ниже приведены 21 методика, которую мы можем использовать для повышения производительности наших приложений React.

## 1. Использование чистых компонентов

Компонент React можно считать чистым, если он выдает одинаковые выходные данные для того же состояния и реквизита. Для таких компонентов класса React предоставляет базовый класс `PureComponent`. Компоненты класса, расширяющие класс `React.PureComponent`, рассматриваются как чистые компоненты.

Это то же самое, что и обычный компонент, за исключением того факта, что `PureComponents` заботится о `shouldComponentUpdate` - он выполняет *поверхностное сравнение* состояния и данных реквизита - props. Если предыдущее состояние и данные реквизита совпадают со следующими реквизитами или состоянием, компонент не визуализируется повторно.

### Что такое неглубокий рендеринг.

При сравнении предыдущих реквизитов - props и состояния - state со следующим, поверхностное сравнение проверит, что примитивы имеют одинаковое значение (например, `1` равно `1` или что `true` равно `true`) и что *ссылки (references)* одинаковы между более сложными значениями JavaScript, такими как объекты и массивы.

Сравнение примитивных и объектных ссылок является более дешевой операцией, чем обновление представления компонента. Поэтому поиск изменений в состоянии и значениях реквизита будет выполняться быстрее, а не делать ненужные обновления.

```javascript

import React from 'react';

export default class ApplicationComponent extends React.Component {

    constructor() {
        super();
        this.state = {
            name: "Mayank"
        }
    }

    updateState = () => {
        setInterval(() => {
            this.setState({
                name: "Mayank"
            })
        }, 1000)
    }

    componentDidMount() {
        this.updateState();
    }

    render() {

        console.log("Render Called Again")
        return (
            <div>
                <RegularChildComponent name={this.state.name} />
                <PureChildComponent name={this.state.name} />
            </div>
        )
    }
}

class RegularChildComponent extends React.Component {
    render() {
        console.log("Regular Component Rendered..");
        return <div>{this.props.name}</div>;
    }
}

class PureChildComponent extends React.PureComponent {
    
    // Pure Components are the components that do not re-render if the State data or props data is still the same   
    
    render() {
        console.log("Pure Component Rendered..")
        return <div>{this.props.name}</div>;
    }
}
```

В приведенном выше примере состояние распространяется на дочерние компоненты `RegularChildComponent` и `PureChildComponent`. `PureChildComponent` является чистым компонентом. После интервала в 1 секунду вызывается `setState`, который повторно запускает рендеринг представления для компонента, поскольку начальные значения и новые значения параметров одинаковы, компонент (`PureChildComponent`) не будет повторно отображаться.

Неглубокое сравнение состояния показывает, что никаких изменений в данных нет ни для реквизита, ни для состояния, поэтому компонент не нужно визуализировать. Следовательно, делая компонент более эффективным.

## 2. Используйте React.memo для запоминания компонентов.

`React.memo` является компонентом высшего порядка. Он похож на `PureComponent`, но `PureComponent` относится к реализации класса для `Component`, тогда как **«memo»** используется для создания функциональных компонентов.

Подобно чистым компонентам, если входные свойства одинаковы, рендеринг компонента будет пропущен, что сделает компонент более быстрым и эффективным. Он запоминает результаты последнего выполнения для определенных входных параметров и повышает производительность приложения. Даже в этих компонентах сравнение невелико. Вы также можете передать пользовательскую логику сравнения для этого компонента.

Пользовательская логика может позволить пользователю искать *глубокое сравнение* объекта, если функция сравнения возвращает `false`, компонент будет перерисован, в противном случае перерисовка компонента отсутствует.

```javascript

function CustomisedComponen(props) {
    return (
        <div>
            <b>User name: {props.name}</b>
            <b>User age: {props.age}</b>
            <b>User designation: {props.designation}</b>
        </div>
    )
}

// The component below is the optimised version for the Default Componenent

// The Component will not re-render if same props value for "name" property 

var memoComponent = React.memo(CustomisedComponent);

```
Вышеупомянутый компонент будет выполнять *поверхностное сравнение* для предыдущего и следующего значения реквизита, в случаях, когда у нас есть ссылки на объекты, переданные в качестве реквизитов для компонента «memo», для сравнения должен быть установлен некоторый пользовательский логин, в таких случаях мы можем передать функцию сравнения в качестве второго параметра в функцию **«React.memo»**.

Предположим, что значение реквизита - props («user») является ссылкой на объект, содержащей «name», «age» и обозначение - «designation» для конкретного пользователя. В этом случае необходимо провести *глубокое сравнение*, мы можем создать пользовательскую функцию, которая ищет значение имени, возраста и назначения для предыдущего и следующего значения реквизита и возвращает `false`, если они не совпадают. Таким образом, наш компонент не будет повторно визуализироваться, даже если у нас есть справочные данные в качестве входных данных для компонента «memo».

```javascript

// The following function takes "user" Object as input parameter in props

function CustomisedComponen(props) {
    return (
        <div>
            <b>User name: {props.user.name}</b>
            <b>User age: {props.user.age}</b>
            <b>User designation: {props.user.designation}</b>
        </div>
    )
}

function userComparator(previosProps, nextProps) {
    if(previosProps.user.name == nextProps.user.name ||
       previosProps.user.age == nextProps.user.age ||
       previosProps.user.designation == nextProps.user.designation) {
        return false
    } else {
        return true;
    }
}

var memoComponent = React.memo(CustomisedComponent, userComparator);

```

В приведенном выше коде, мы представили пользовательскую логику для сравнения.

## 3. Использование события жизненного цикла `shouldComponentUpdate`.

Это одно из событий жизненного цикла, которое запускается перед повторной визуализацией компонента. Мы можем эффективно использовать это событие, чтобы решить, когда компонент должен быть перерисован. Эта функция возвращает логическое значение в случае, если компонент поддерживает изменения или вызывается setState. В обоих случаях компонент имеет тенденцию к повторной визуализации. Мы можем поместить собственную логику в это событие жизненного цикла, чтобы решить, будет ли вызвана функция рендеринга компонента.

Эта функция принимает в качестве входных данных `nextState` и `nextProps` и может сравнивать их с текущими реквизитами и состоянием, чтобы определить необходимость повторной визуализации.